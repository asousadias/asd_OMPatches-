; OM File Header - Saved 2018/05/06 21:37:00
; (6.130002 :patc (om-make-point 255 17) (om-make-point 50 50) (om-make-point 1203 729) "" 183 0 nil "2018/05/06 21:36:32")
; End File Header
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "glosa-figur-help_all" (quote ((let ((box (om-load-boxcall (quote abstraction) "glosa-figur1" (om-load-patch-abs1 "glosa-figur" (quote ((let ((box (om-load-boxcall (quote abstraction) "mypatch2" (om-load-patch-abs1 "list (E d)" (quote ((let ((box (om-load-boxcomment "comment" (om-make-point 145 120) (quote "Outputs a list of lists containing:$((note$intervToNextNote$index)$...$)") "" (om-make-point 204 385) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST1" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 0 331) (om-make-point 168 39) nil nil "list" 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 1))) (om-make-point 204 191) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ARITHM-SER" (quote arithm-ser) (quote ((om-load-inputfun (quote input-funbox) "begin" "BEGIN" 0) (om-load-inputfun (quote input-funbox) "end " "END" 10) (om-load-inputfun (quote input-funbox) "step" "STEP" 1))) (om-make-point 184 255) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "the list" "MATRIX" nil))) (om-make-point 54 377) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X->DX" (quote x->dx) (quote ((om-load-inputfun (quote input-funbox) "a list of numbers" "SELF" 0))) (om-make-point 58 188) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first list" "L1?" nil) (om-load-inputfun (quote input-funbox) "second list" "L2?" nil))) (om-make-point 52 132) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FIRST-N" (quote first-n) (quote ((om-load-inputfun (quote input-funbox) "one list" "LIST" nil) (om-load-inputfun (quote input-funbox) "number of elements" "N" 0))) (om-make-point 138 185) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 195 127) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 62 443) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 29 34) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((10 0 1 0 nil 0) (7 0 1 1 nil 0) (3 0 1 2 nil 0) (8 0 2 0 nil 0) (2 0 3 1 nil 0) (1 0 4 0 nil 0) (6 0 5 0 nil 0) (10 0 6 0 nil 0) (10 0 6 1 nil 0) (5 0 7 0 nil 0) (8 0 7 1 nil 0) (10 0 8 0 nil 0) (4 0 9 0 nil 0))) 6.130002 nil "" (om-make-point 200 200) (om-make-point 400 500)) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input" nil))) (om-make-point 3 70) nil nil nil "list (E d)"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment3" (om-make-point 333 111) (quote "Given a melodic sequence as a Cantus Firmus (CF) and a melodic sequence as an ornamentation reservoir (MS), for each two notes of the CF, this patch generates all excerpts from MS whose extreme notes form the same interval.$The resulting data is more suitable to be read by a score editor.") "" (om-make-point 625 7) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 234 151) (quote "The inputs are:$1- CF (list of MIDI)$2- Melodic sequence  (list of MIDI)$3- Length of CF notes$4- Length of each generated note$5- Number of lines (channels)$The outputs connect to a chord-seq object.$") "" (om-make-point 707 120) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment1" (om-make-point 156 64) (quote "AntÛnio de Sousa Dias$www.sousadias.com$rev. 2008") "" (om-make-point 771 274) nil (om-make-color 0.018735297 0.025613498 0.51131225) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input4" 4 (om-make-point 492 123) "nº de linhas ao alto por figuração" "number of lines" 15 nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch1" (om-load-patch-abs1 "sort_map" (quote ((let ((box (om-load-boxin "input4" 4 (om-make-point 499 45) "no documentation" "num de linhas" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND111" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first list" "L1?" nil) (om-load-inputfun (quote input-funbox) "second list" "L2?" nil))) (om-make-point 372 320) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND11" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first list" "L1?" nil) (om-load-inputfun (quote input-funbox) "second list" "L2?" nil))) (om-make-point 280 321) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND1" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first list" "L1?" nil) (om-load-inputfun (quote input-funbox) "second list" "L2?" nil))) (om-make-point 207 316) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first list" "L1?" nil) (om-load-inputfun (quote input-funbox) "second list" "L2?" nil))) (om-make-point 126 316) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch1" (om-load-patch-abs1 "motivo glosado" (quote ((let ((box (om-load-boxin "input3" 3 (om-make-point 548 331) "no documentation" "n de linhas ao alto" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "ordena linhas" (quote ((let ((box (om-load-boxin "input3" 3 (om-make-point 420 183) "no documentation" "n de linhas" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 277 437) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 152 430) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "the list" "MATRIX" nil))) (om-make-point 217 366) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "LONSET" nil) (om-load-inputfun (quote input-funbox) "no documentation" "dur max" nil) (om-load-inputfun (quote input-funbox) "no documentation" "LMIDI" nil) (om-load-inputfun (quote input-funbox) "no documentation" "n de linhas" nil))) (om-make-point 203 284) nil nil nil (list (let ((box (om-load-boxin "input3" 3 (om-make-point 449 84) "no documentation" "n de linhas" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first list" "L1?" nil) (om-load-inputfun (quote input-funbox) "second list" "L2?" nil))) (om-make-point 263 299) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 0))) (om-make-point 263 225) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM+" (quote om+) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 0))) (om-make-point 216 256) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM//" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or tree" "SELF" 1) (om-load-inputfun (quote input-funbox) "number or tree" "DIVISOR" 1))) (om-make-point 319 229) nil nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH1" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "N" "N" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 315 169) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "N" "N" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 260 168) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "WHAT?" nil))) (om-make-point 224 355) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 1))) (om-make-point 130 98) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 60 116) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "for" (quote forloop) (quote ((om-load-inputfun (quote input-funbox) "low val" "FROM" 0) (om-load-inputfun (quote input-funbox) "high val" "TO" 10))) (om-make-point 118 144) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input2" 2 (om-make-point 351 35) "no documentation" "LMIDI" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 258 39) "no documentation" "dur max" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 145 35) "no documentation" "LONSET" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 408 369) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 37 359) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((3 0 1 0 nil 0) (4 1 1 1 nil 0) (12 0 2 0 nil 0) (4 0 2 1 nil 0) (6 0 3 0 nil 0) (2 0 3 1 nil 0) (5 0 4 0 nil 0) (0 0 4 1 nil 0) (10 0 5 0 nil 0) (11 0 5 1 nil 0) (10 0 6 0 nil 0) (13 0 6 1 nil 0) (1 0 7 0 nil 0) (9 0 8 0 nil 0) (13 0 9 0 nil 0) (8 0 10 1 nil 0) (7 1 14 0 nil 0) (7 0 15 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output1" 1 (om-make-point 378 436) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 54 438) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input2" 2 (om-make-point 291 86) "no documentation" "lchannel" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 123 86) "no documentation" "durmax" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 34 174) "no documentation" "lonset" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((3 0 1 0 nil 0) (3 0 2 0 nil 0) (4 0 3 0 nil 0) (9 0 4 0 nil 0) (8 0 4 1 nil 0) (7 0 4 2 nil 0) (0 0 4 3 nil 0) (1 0 5 0 nil 0) (2 0 6 0 nil 0))) 6.130002 nil "" (om-make-point 200 200) (om-make-point 400 500)) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "lonset" nil) (om-load-inputfun (quote input-funbox) "no documentation" "durmax" nil) (om-load-inputfun (quote input-funbox) "no documentation" "lchannel" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input3" nil))) (om-make-point 438 392) nil nil nil "ordena linhas"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*1" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 2))) (om-make-point 230 101) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT21" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "one list" "LST" nil) (om-load-inputfun (quote input-funbox) "level of parenthesis" "LEVEL" nil))) (om-make-point 236 328) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP11" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input0" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input1" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input2" nil))) (om-make-point 208 270) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 0))) (om-make-point 178 238) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "DX->X" (quote dx->x) (quote ((om-load-inputfun (quote input-funbox) "a number" "START" 0) (om-load-inputfun (quote input-funbox) "a list of numbers" "LIST" (list 1 1)))) (om-make-point 218 319) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 1))) (om-make-point 338 251) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input2" 2 (om-make-point 475 46) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 377 45) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "N" "N" 0) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 163 149) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 334 204) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "REPEAT-N" (quote repeat-n) (quote ((om-load-inputfun (quote input-funbox) "patch" "SELF" nil) (om-load-inputfun (quote input-funbox) "times" "NUM" 0))) (om-make-point 250 233) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTHCDR" (quote nthcdr) (quote ((om-load-inputfun (quote input-funbox) "N" "N" 2) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 224 148) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "WHAT?" nil))) (om-make-point 227 384) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 227 62) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 145 52) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 388 412) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 46 407) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((5 0 0 0 nil 0) (4 0 0 1 nil 0) (0 0 1 0 nil 0) (7 0 1 1 nil 0) (6 0 2 0 nil 0) (10 0 5 1 nil 0) (8 0 6 0 nil 0) (3 0 7 0 nil 0) (2 0 7 1 nil 0) (10 0 8 1 nil 0) (1 0 9 0 nil 0) (11 0 10 0 nil 0) (9 1 12 0 nil 0) (9 0 13 0 nil 0))) 1 "omloop11" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM+" (quote om+) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 2))) (om-make-point 420 481) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT2" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "one list" "LST" nil))) (om-make-point 550 253) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT1" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "one list" "LST" nil))) (om-make-point 301 352) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "REPEAT-N" (quote repeat-n) (quote ((om-load-inputfun (quote input-funbox) "patch" "SELF" nil) (om-load-inputfun (quote input-funbox) "times" "NUM" 0))) (om-make-point 360 284) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 296 200) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP1" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input0" nil))) (om-make-point 468 250) nil nil nil (list (let ((box (om-load-boxcall (quote lispfun) "NTH" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "N" "N" 1) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 198 149) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 324 199) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "REPEAT-N" (quote repeat-n) (quote ((om-load-inputfun (quote input-funbox) "patch" "SELF" nil) (om-load-inputfun (quote input-funbox) "times" "NUM" 0))) (om-make-point 221 217) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTHCDR" (quote nthcdr) (quote ((om-load-inputfun (quote input-funbox) "N" "N" 2) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 278 152) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "WHAT?" nil))) (om-make-point 210 312) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 227 62) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 145 52) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 378 317) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 44 308) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((5 0 0 1 nil 0) (3 0 1 0 nil 0) (0 0 2 0 nil 0) (1 0 2 1 nil 0) (5 0 3 1 nil 0) (2 0 4 0 nil 0) (6 0 5 0 nil 0) (4 1 7 0 nil 0) (4 0 8 0 nil 0))) 1 "omloop1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "one list" "LST" nil))) (om-make-point 41 262) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input0" nil))) (om-make-point 28 146) nil nil nil (list (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 81 150) (om-make-point 27 30) 2 "2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTHCDR" (quote nthcdr) (quote ((om-load-inputfun (quote input-funbox) "N" "N" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 116 216) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 129 121) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "WHAT?" nil))) (om-make-point 132 261) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 207 59) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 176 316) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 70 319) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((0 0 1 0 nil 0) (2 0 1 1 nil 0) (4 0 2 0 nil 0) (1 0 3 0 nil 0) (3 1 5 0 nil 0) (3 0 6 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output3" 3 (om-make-point 458 506) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output2" 2 (om-make-point 346 382) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output1" 1 (om-make-point 209 472) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 90 386) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input2" 2 (om-make-point 406 11) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 318 10) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 71 17) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((3 0 1 0 nil 0) (18 0 1 1 nil 0) (6 0 1 2 nil 0) (0 0 1 3 nil 0) (18 0 2 0 nil 0) (4 0 3 0 nil 0) (19 0 4 0 nil 0) (2 0 4 1 nil 0) (17 0 4 2 nil 0) (1 1 5 0 nil 0) (10 0 6 0 nil 0) (8 0 7 0 nil 0) (17 0 8 0 nil 0) (9 0 8 1 nil 0) (11 0 9 0 nil 0) (19 0 10 0 nil 0) (12 0 11 0 nil 0) (19 0 12 0 nil 0) (5 0 13 0 nil 0) (7 0 14 0 nil 0) (1 0 15 0 nil 0) (11 0 16 0 nil 0))) 6.130002 nil "" (om-make-point 200 200) (om-make-point 400 500)) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input1" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input2" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input3" nil))) (om-make-point 427 220) nil nil nil "motivo glosado"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "motivo CF" (quote ((let ((box (om-load-boxcall (quote bastype) "aux3" (quote t) (quote nil) (om-make-point 245 216) (om-make-point 13 28) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux2" (quote t) (quote nil) (om-make-point 227 122) (om-make-point 13 28) 2 "2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 2))) (om-make-point 198 122) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 1) (om-load-inputfun (quote input-funbox) "second input" "NUM" 1))) (om-make-point 218 213) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*1" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 100))) (om-make-point 181 253) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ARITHM-SER" (quote arithm-ser) (quote ((om-load-inputfun (quote input-funbox) "begin" "BEGIN" 0) (om-load-inputfun (quote input-funbox) "end " "END" 10) (om-load-inputfun (quote input-funbox) "step" "STEP" 1))) (om-make-point 100 189) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 316 196) (om-make-point 23 24) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "REPEAT-N1" (quote repeat-n) (quote ((om-load-inputfun (quote input-funbox) "patch" "SELF" nil) (om-load-inputfun (quote input-funbox) "times" "NUM" 0))) (om-make-point 259 229) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "REPEAT-N" (quote repeat-n) (quote ((om-load-inputfun (quote input-funbox) "patch" "SELF" nil) (om-load-inputfun (quote input-funbox) "times" "NUM" 0))) (om-make-point 327 227) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 343 117) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output3" 3 (om-make-point 352 313) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output2" 2 (om-make-point 261 313) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output1" 1 (om-make-point 156 309) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 16 311) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input2" 2 (om-make-point 327 35) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 226 18) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 21 37) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((15 0 2 0 nil 0) (1 0 2 1 nil 0) (9 0 3 0 nil 0) (0 0 3 1 nil 0) (5 0 4 0 nil 0) (2 0 4 1 nil 0) (3 0 5 1 nil 0) (2 0 7 0 nil 0) (9 0 7 1 nil 0) (6 0 8 0 nil 0) (9 0 8 1 nil 0) (16 0 9 0 nil 0) (8 0 10 0 nil 0) (7 0 11 0 nil 0) (4 0 12 0 nil 0) (16 0 13 0 nil 0))) 6.130002 nil "" (om-make-point 200 200) (om-make-point 400 500)) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input1" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input2" nil))) (om-make-point 140 208) nil nil nil "motivo CF"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output3" 3 (om-make-point 377 389) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) "lchannels" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output2" 2 (om-make-point 270 391) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) "ldurs" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output1" 1 (om-make-point 193 385) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) "lonsets" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 111 388) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) "lmidicents" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input3" 3 (om-make-point 400 9) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input2" 2 (om-make-point 302 35) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 217 60) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 105 95) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((6 3 1 0 nil 0) (5 3 1 1 nil 0) (6 2 2 0 nil 0) (5 2 2 1 nil 0) (6 1 3 0 nil 0) (5 1 3 1 nil 0) (6 0 4 0 nil 0) (5 0 4 1 nil 0) (13 0 5 0 nil 0) (12 0 5 1 nil 0) (11 0 5 2 nil 0) (0 0 5 3 nil 0) (14 0 6 0 nil 0) (12 0 6 1 nil 0) (11 0 6 2 nil 0) (1 0 7 0 nil 0) (2 0 8 0 nil 0) (3 0 9 0 nil 0) (4 0 10 0 nil 0))) 6.130002 nil "" (om-make-point 200 200) (om-make-point 400 500)) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input1" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input2" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input3" nil) (om-load-inputfun (quote input-funbox) "no documentation" "nº de linhas" nil))) (om-make-point 287 195) (om-make-point 294 63) nil "&" "sort_map"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output4" 4 (om-make-point 495 270) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) "lchannels" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input3" 3 (om-make-point 462 74) "duração minima entre valores" "dur_min" 125 nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input2" 2 (om-make-point 411 26) "duração para compassos de material" "dur_base" 2000 nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP2" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input0" nil))) (om-make-point 55 144) nil nil "&" (list (let ((box (om-load-boxcall (quote lispfun) "REMOVE1" (quote remove) (quote ((om-load-inputfun (quote input-funbox) "ITEM" "ITEM" nil) (om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 297 286) nil nil nil "remove" 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux1" (quote t) (quote nil) (om-make-point 342 114) (om-make-point 61 26) (quote lista_base) "lista_base" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "EVAL" (quote eval) (quote ((om-load-inputfun (quote input-funbox) "FORM" "FORM" nil))) (om-make-point 356 168) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "SEQUENCE" (quote sequence) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil) (om-load-inputfun (quote input-funbox) "patch" "OPPATCH" nil))) (om-make-point 293 240) nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "remove_l_dups" (om-load-patch-abs1 "remove_l_dups" (quote ((let ((box (om-load-boxin "input1" 1 (om-make-point 183 21) "no documentation" "nome variavel" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "ARG-0" "ARG-0" nil))) (om-make-point 2 148) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM>" (quote om>) (quote ((om-load-inputfun (quote input-funbox) "a number" "SELF" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM" 1))) (om-make-point 46 185) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "if" "TEST" nil) (om-load-inputfun (quote input-funbox) "then" "ACTION" nil) (om-load-inputfun (quote input-funbox) "else" "ELSE" nil))) (om-make-point 78 210) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "lista de listas" nil) (om-load-inputfun (quote input-funbox) "no documentation" "nome_variavel" nil))) (om-make-point 157 125) nil nil nil (list (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input0" nil) (om-load-inputfun (quote input-funbox) "no documentation" "lista de listas" nil) (om-load-inputfun (quote input-funbox) "no documentation" "nome de variavel" nil))) (om-make-point 219 182) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "WHAT?" nil))) (om-make-point 174 330) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "compare_elements" (quote ((let ((box (om-load-boxcall (quote lispfun) "LIST" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 449 147) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "SET" (quote set) (quote ((om-load-inputfun (quote input-funbox) "SYMBOL" "SYMBOL" nil) (om-load-inputfun (quote input-funbox) "VALUE" "VALUE" nil))) (om-make-point 388 269) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "EVAL" (quote eval) (quote ((om-load-inputfun (quote input-funbox) "FORM" "FORM" nil))) (om-make-point 414 170) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "SUBS-POSN" (quote subs-posn) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIS1" (list 0 1 2 3)) (om-load-inputfun (quote input-funbox) " a list of indexes" "POSN" (list 1 3)) (om-load-inputfun (quote input-funbox) "a list" "VAL" (list nil)))) (om-make-point 434 221) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF1" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "if" "TEST" nil) (om-load-inputfun (quote input-funbox) "then" "ACTION" nil))) (om-make-point 310 345) (om-make-point 131 53) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMAND" (quote omand) (quote ((om-load-inputfun (quote input-funbox) "patch" "SELF" nil) (om-load-inputfun (quote input-funbox) "add patch" "REST" nil))) (om-make-point 309 303) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=11" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "SELF" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM" 0))) (om-make-point 322 232) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=1" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "SELF" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM" 0))) (om-make-point 271 233) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "LIST-MAX" (quote list-max) (quote ((om-load-inputfun (quote input-funbox) "a list" "SELF" (list 0 1 2)))) (om-make-point 330 182) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "LIST-MIN" (quote list-min) (quote ((om-load-inputfun (quote input-funbox) "a list" "SELF" (list 0 1 2)))) (om-make-point 270 182) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "if" "TEST" nil) (om-load-inputfun (quote input-funbox) "then" "ACTION" nil))) (om-make-point 232 398) (om-make-point 131 53) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "SELF" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM" 0))) (om-make-point 142 261) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 0))) (om-make-point 266 137) (om-make-point 78 27) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH1" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 149 149) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 103 149) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH1" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "N" "N" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 158 102) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "N" "N" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 95 103) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 282 460) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input3" 3 (om-make-point 405 17) "no documentation" "nome variavel" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input2" 2 (om-make-point 259 43) "no documentation" "lista de listas" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 147 12) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 91 17) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((20 0 0 0 nil 0) (18 0 1 0 nil 0) (3 0 1 1 nil 0) (18 0 2 0 nil 0) (2 0 3 0 nil 0) (0 0 3 1 nil 0) (5 0 4 0 nil 0) (1 0 4 1 nil 0) (7 0 5 0 nil 0) (6 0 5 1 nil 0) (8 0 6 0 nil 0) (9 0 7 0 nil 0) (12 0 8 0 nil 0) (12 0 9 0 nil 0) (11 0 10 0 nil 0) (4 0 10 1 nil 0) (14 0 11 0 nil 0) (13 0 11 1 nil 0) (16 0 12 0 nil 0) (15 0 12 1 nil 0) (15 0 13 0 nil 0) (16 0 14 0 nil 0) (20 0 15 0 nil 0) (19 0 15 1 nil 0) (21 0 16 0 nil 0) (19 0 16 1 nil 0) (10 0 17 0 nil 0))) 6.130002 nil "" (om-make-point 200 200) (om-make-point 400 500)) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input1" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input2" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input3" nil))) (om-make-point 31 236) (om-make-point 353 61) nil nil "compare_elements"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM+" (quote om+) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 1))) (om-make-point 110 113) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "for" (quote forloop) (quote ((om-load-inputfun (quote input-funbox) "low val" "FROM" 0) (om-load-inputfun (quote input-funbox) "high val" "TO" 10))) (om-make-point 128 174) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "ARG-0" "ARG-0" nil))) (om-make-point 147 118) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 2))) (om-make-point 183 156) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux3" (quote t) (quote nil) (om-make-point 186 127) (om-make-point 11 20) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input2" 2 (om-make-point 349 31) "no documentation" "nome de variavel" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 234 30) "no documentation" "lista de listas" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 5 40) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 320 301) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 43 309) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((1 0 0 0 nil 0) (9 0 1 0 nil 0) (3 0 1 1 nil 0) (8 0 1 2 nil 0) (7 0 1 3 nil 0) (9 0 2 0 nil 0) (2 0 3 0 nil 0) (5 0 3 1 nil 0) (8 0 4 0 nil 0) (4 0 5 0 nil 0) (6 0 5 1 nil 0) (0 1 10 0 nil 0) (0 0 11 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "WHAT?" nil))) (om-make-point 211 293) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "ARG-0" "ARG-0" nil))) (om-make-point 43 112) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 2))) (om-make-point 79 150) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux3" (quote t) (quote nil) (om-make-point 147 96) (om-make-point 18 28) 2 "2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "for" (quote forloop) (quote ((om-load-inputfun (quote input-funbox) "low val" "FROM" 0) (om-load-inputfun (quote input-funbox) "high val" "TO" 10))) (om-make-point 127 162) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 392 44) "no documentation" "nome_variavel" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 50 42) "no documentation" "lista de listas" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 332 314) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 46 317) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((5 0 0 0 nil 0) (7 0 0 1 nil 0) (6 0 0 2 nil 0) (0 0 1 0 nil 0) (7 0 2 0 nil 0) (2 0 3 0 nil 0) (4 0 3 1 nil 0) (3 0 5 1 nil 0) (1 1 8 0 nil 0) (1 0 9 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "SET" (quote set) (quote ((om-load-inputfun (quote input-funbox) "ARG-0" "ARG-0" nil) (om-load-inputfun (quote input-funbox) "ARG-1" "ARG-1" nil))) (om-make-point 51 75) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 53 314) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) "lista_s_dups" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 51 6) "lista" "lista de listas" (list nil) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((5 0 1 0 nil 0) (1 0 2 0 nil 0) (2 0 3 0 nil 0) (4 0 3 1 nil 0) (5 0 3 2 nil 0) (5 0 4 0 nil 0) (0 0 4 1 nil 0) (0 0 5 0 nil 0) (7 0 5 1 nil 0) (3 0 6 0 nil 0))) 6.130002 nil "" (om-make-point 200 200) (om-make-point 400 500)) (quote ((om-load-inputfun (quote input-funbox) "lista" "lista" (list nil)) (om-load-inputfun (quote input-funbox) "no documentation" "input1" nil))) (om-make-point 225 151) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "WHAT?" nil))) (om-make-point 182 342) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 129 108) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 137 43) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 299 360) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 93 359) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((3 1 0 1 nil 0) (1 0 2 0 nil 0) (4 0 3 0 nil 0) (2 0 3 1 nil 0) (6 0 4 0 nil 0) (1 0 4 1 nil 0) (0 0 5 0 nil 0) (7 0 6 0 nil 0) (5 1 8 0 nil 0) (5 0 9 0 nil 0))) 1 "remover listas dups" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 266 101) (om-make-point 19 25) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "one list" "LST" nil) (om-load-inputfun (quote input-funbox) "level of parenthesis" "LEVEL" nil))) (om-make-point 219 116) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output3" 3 (om-make-point 448 271) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) "ldurs" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP1" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input0" nil))) (om-make-point 60 211) nil nil "&" (list (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input0" nil))) (om-make-point 114 134) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first list" "L1?" nil) (om-load-inputfun (quote input-funbox) "second list" "L2?" nil) (om-load-inputfun (quote input-funbox) "add list" "LST?" nil))) (om-make-point 234 263) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CDR" (quote cdr) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 333 225) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CAR" (quote car) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 287 195) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "N" "N" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 347 173) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 184 59) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 1))) (om-make-point 153 78) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "for" (quote forloop) (quote ((om-load-inputfun (quote input-funbox) "low val" "FROM" 0) (om-load-inputfun (quote input-funbox) "high val" "TO" 10))) (om-make-point 138 123) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "WHAT?" nil))) (om-make-point 225 317) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 255 34) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 350 305) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 53 302) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((2 0 0 0 nil 0) (6 0 0 1 nil 0) (1 0 0 2 nil 0) (3 0 1 0 nil 0) (3 0 2 0 nil 0) (6 0 3 0 nil 0) (8 0 3 1 nil 0) (8 0 4 0 nil 0) (4 0 5 0 nil 0) (5 0 6 1 nil 0) (0 0 7 0 nil 0) (7 1 9 0 nil 0) (7 0 10 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "WHAT?" nil))) (om-make-point 215 178) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 208 78) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 124 40) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 335 253) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 76 260) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((2 0 0 0 nil 0) (0 0 1 0 nil 0) (3 0 2 0 nil 0) (1 1 4 0 nil 0) (1 0 5 0 nil 0))) 1 "inserir canal midi" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output2" 2 (om-make-point 383 270) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) "lonsets" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "list_1" nil) (om-load-inputfun (quote input-funbox) "no documentation" "list_2" nil))) (om-make-point 88 83) nil nil "&" (list (let ((box (om-load-boxcomment "comment" (om-make-point 100 40) (quote "duplicate list to circulation") "" (om-make-point 432 77) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 272 156) (om-make-point 35 32) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "one list" "LST" nil) (om-load-inputfun (quote input-funbox) "level of parenthesis" "LEVEL" nil))) (om-make-point 234 219) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment1" (om-make-point 73 27) (quote "list to study") "" (om-make-point 466 26) nil (om-make-color 0 0 0) (om-make-font "Geneva" 10 :family "Geneva" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 136 58) (quote "(note$interval to next note$index)") "" (om-make-point 125 65) nil (om-make-color 0 0 0) (om-make-font "Geneva" 10 :family "Geneva" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first list" "L1?" nil) (om-load-inputfun (quote input-funbox) "second list" "L2?" nil))) (om-make-point 364 61) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "lista 1" nil) (om-load-inputfun (quote input-funbox) "no documentation" "lista 2" nil))) (om-make-point 223 149) nil nil nil (list (let ((box (om-load-boxcomment "comment2" (om-make-point 136 58) (quote "(note$interval to next note$index)") "" (om-make-point 32 137) nil (om-make-color 0 0 0) (om-make-font "Geneva" 10 :family "Geneva" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment11" (om-make-point 73 27) (quote "list to study") "" (om-make-point 402 17) nil (om-make-color 0 0 0) (om-make-font "Geneva" 10 :family "Geneva" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 309 93) (om-make-point 14 27) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 94 21) (quote "first for loop") "" (om-make-point 358 138) nil (om-make-color 0 0 0) (om-make-font "Geneva" 10 :family "Geneva" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input0" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input1" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input2" nil))) (om-make-point 172 172) nil nil nil (list (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 503 279) (om-make-point 29 38) 2 "2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "one list" "LST" nil) (om-load-inputfun (quote input-funbox) "level of parenthesis" "LEVEL" nil))) (om-make-point 445 344) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "if" "TEST" nil) (om-load-inputfun (quote input-funbox) "then" "ACTION" nil))) (om-make-point 225 451) (om-make-point 145 53) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 94 21) (quote "second for loop") "" (om-make-point 475 234) nil (om-make-color 0 0 0) (om-make-font "Geneva" 10 :family "Geneva" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch1" (om-load-patch-abs1 "fabrica" (quote ((let ((box (om-load-boxcall (quote abstraction) "mypatch1" (om-load-patch-abs1 "intervalos reduzidos" (quote ((let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "SELF" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM" 0))) (om-make-point 186 182) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 265 31) (om-make-point 45 33) 12 "12" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM//1" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or tree" "SELF" 1) (om-load-inputfun (quote input-funbox) "number or tree" "DIVISOR" 1))) (om-make-point 245 156) (om-make-point 33 53) nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM//" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or tree" "SELF" 1) (om-load-inputfun (quote input-funbox) "number or tree" "DIVISOR" 1))) (om-make-point 139 97) nil nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 212 261) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 208 89) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 102 16) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((3 1 0 0 nil 0) (2 1 0 1 nil 0) (5 0 2 0 nil 0) (1 0 2 1 nil 0) (6 0 3 0 nil 0) (1 0 3 1 nil 0) (0 0 4 0 nil 0))) 6.130002 nil "" (om-make-point 200 200) (om-make-point 400 500)) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input1" nil))) (om-make-point 109 317) nil nil nil "intervalos reduzidos"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMOR" (quote omor) (quote ((om-load-inputfun (quote input-funbox) "patch" "SELF" nil) (om-load-inputfun (quote input-funbox) "add patch" "REST" nil))) (om-make-point 64 388) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 80 40) (quote "compara intervalos") "" (om-make-point 85 452) nil (om-make-color 0 0 0) (om-make-font "Geneva" 10 :family "Geneva" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output1" 1 (om-make-point 375 410) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "make sequence" (quote ((let ((box (om-load-boxcall (quote lispfun) "NTH2" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "N" "N" 0) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 105 106) nil nil nil "nth" 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "DX->X" (quote dx->x) (quote ((om-load-inputfun (quote input-funbox) "a number" "START" 0) (om-load-inputfun (quote input-funbox) "a list of numbers" "LIST" (list 1 1)))) (om-make-point 110 163) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ARITHM-SER" (quote arithm-ser) (quote ((om-load-inputfun (quote input-funbox) "begin" "BEGIN" 0) (om-load-inputfun (quote input-funbox) "end " "END" 10) (om-load-inputfun (quote input-funbox) "step" "STEP" 1))) (om-make-point 348 130) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "POSN-MATCH" (quote posn-match) (quote ((om-load-inputfun (quote input-funbox) "list" "LIST" (list 10 20 30 40 50 60 70 80 90)) (om-load-inputfun (quote input-funbox) "positions" "POSITIONS" (list (list 0 1) 4 (list 6))))) (om-make-point 298 211) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X->DX" (quote x->dx) (quote ((om-load-inputfun (quote input-funbox) "a list of numbers" "SELF" 0))) (om-make-point 153 101) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH111" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "N" "N" 2) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 40 108) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first list" "L1?" nil) (om-load-inputfun (quote input-funbox) "second list" "L2?" nil))) (om-make-point 52 317) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input3" 3 (om-make-point 402 18) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 307 325) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input2" 2 (om-make-point 335 18) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 239 6) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 85 6) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((11 0 0 1 nil 0) (0 0 1 0 nil 0) (4 0 1 1 nil 0) (9 0 2 0 nil 0) (7 0 2 1 nil 0) (10 0 3 0 nil 0) (2 0 3 1 nil 0) (3 0 4 0 nil 0) (11 0 5 1 nil 0) (5 0 6 0 nil 0) (1 0 6 1 nil 0) (6 0 8 0 nil 0))) 6.130002 nil "" (om-make-point 200 200) (om-make-point 400 500)) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input1" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input2" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input3" nil))) (om-make-point 354 300) nil nil nil "make sequence"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "one list" "LST" nil))) (om-make-point 154 28) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 24 439) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "SELF" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM" 0))) (om-make-point 19 338) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH11" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "N" "N" 1) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 21 245) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 0))) (om-make-point 142 256) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH1" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "N" "N" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 196 152) nil nil nil "nth" 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "N" "N" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 127 113) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input3" 3 (om-make-point 454 65) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input2" 2 (om-make-point 223 5) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 82 15) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 41 153) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((8 0 0 0 nil 0) (9 0 0 1 nil 0) (7 0 1 0 nil 0) (0 0 1 1 nil 0) (4 0 3 0 nil 0) (15 0 4 0 nil 2) (14 0 4 1 nil 1) (13 0 4 2 nil 0) (12 0 4 3 nil 3) (14 0 5 0 nil 1) (1 0 6 0 nil 0) (8 0 7 0 nil 0) (9 0 7 1 nil 0) (15 0 8 1 nil 2) (10 0 9 0 nil 1) (11 0 9 1 nil 0) (12 0 10 0 nil 3) (5 0 10 1 nil 1) (13 0 11 0 nil 0) (5 0 11 1 nil 1))) 6.130002 nil "" (om-make-point 200 200) (om-make-point 400 500)) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input1" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input2" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input3" nil))) (om-make-point 156 282) (om-make-point 171 63) nil nil "fabrica"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "WHAT?" nil))) (om-make-point 455 408) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "lenght/2-1" (quote ((let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 1))) (om-make-point 218 69) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM//" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or tree" "SELF" 1) (om-load-inputfun (quote input-funbox) "number or tree" "DIVISOR" 2))) (om-make-point 157 65) nil nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 89 72) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 281 68) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 29 53) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (2 0 1 0 nil 0) (4 0 2 0 nil 0) (0 0 3 0 nil 0))) 6.130002 nil "" (om-make-point 200 200) (om-make-point 400 500)) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input" nil))) (om-make-point 548 91) nil nil nil "lenght/2-1"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM+1" (quote om+) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 1))) (om-make-point 511 176) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM+" (quote om+) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 1))) (om-make-point 456 124) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "for" (quote forloop) (quote ((om-load-inputfun (quote input-funbox) "low val" "FROM" 0) (om-load-inputfun (quote input-funbox) "high val" "TO" 10))) (om-make-point 425 229) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input2" 2 (om-make-point 357 102) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 235 44) "no documentation" nil nil (om-make-point 41 53)))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 145 41) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 450 501) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 274 517) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((4 1 1 0 nil 0) (0 0 1 1 nil 0) (4 0 2 0 nil 0) (5 0 2 1 nil 0) (12 0 4 0 nil 2) (11 0 4 1 nil 1) (10 0 4 2 nil 0) (9 0 4 3 nil 0) (1 0 5 0 nil 0) (11 0 6 0 nil 1) (8 0 7 0 nil 0) (6 0 7 1 nil 0) (10 0 8 0 nil 0) (8 0 9 0 nil 0) (7 0 9 1 nil 0) (5 1 13 0 nil 0) (2 0 14 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "lenght/2-1" (quote ((let ((box (om-load-boxcall (quote bastype) "aux1" (quote t) (quote nil) (om-make-point 224 24) (om-make-point 13 28) 2 "2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 263 98) (om-make-point 13 28) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "one list" "LST" nil))) (om-make-point 87 57) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 1))) (om-make-point 231 134) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM//" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or tree" "SELF" 1) (om-load-inputfun (quote input-funbox) "number or tree" "DIVISOR" 2))) (om-make-point 208 54) nil nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 147 58) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 324 119) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 29 53) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((7 0 2 0 nil 0) (4 0 3 0 nil 0) (1 0 3 1 nil 0) (5 0 4 0 nil 0) (0 0 4 1 nil 0) (2 0 5 0 nil 0) (3 0 6 0 nil 0))) 6.130002 nil "" (om-make-point 200 200) (om-make-point 400 500)) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input" nil))) (om-make-point 406 67) nil nil nil "lenght/2-1"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "for" (quote forloop) (quote ((om-load-inputfun (quote input-funbox) "low val" "FROM" 0) (om-load-inputfun (quote input-funbox) "high val" "TO" 10))) (om-make-point 314 127) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "WHAT?" nil))) (om-make-point 176 302) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 251 32) "no documentation" "lista 2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 60 40) "no documentation" "lista 1" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 258 331) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 87 337) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((9 0 4 0 nil 2) (8 0 4 1 nil 1) (6 0 4 2 nil 0) (8 0 5 0 nil 0) (2 0 6 0 nil 0) (5 0 6 1 nil 0) (4 0 7 0 nil 0) (7 1 10 0 nil 0) (7 0 11 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 78 61) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "WHAT?" nil))) (om-make-point 336 198) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 419 2) "no documentation" "list_2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 5 40) "no documentation" "list_1" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 379 273) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 299 273) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((6 0 2 0 nil 0) (1 0 2 1 nil 0) (9 0 5 0 nil 0) (9 0 5 1 nil 0) (7 0 6 0 nil 0) (5 0 6 1 nil 0) (10 0 7 0 nil 0) (2 0 8 0 nil 0) (8 1 11 0 nil 0) (8 0 12 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output1" 1 (om-make-point 326 268) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) "lmidic" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 199 266) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) "output lists" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 373 8) "valores a utilisar como glosa" "list 2" (list 65 66 63 62) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 323 7) "lista de CF" "list 1" (list 60 71 63 74) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((19 0 0 0 nil 0) (19 0 5 0 nil 0) (11 0 5 1 nil 1) (8 0 5 2 nil 0) (7 0 5 3 nil 0) (4 0 5 4 nil 0) (5 3 6 0 nil 0) (15 0 9 0 nil 0) (13 0 11 0 nil 0) (10 0 11 1 nil 0) (5 2 12 0 nil 0) (9 0 13 0 nil 0) (5 1 14 0 nil 0) (0 0 15 0 nil 0) (18 0 15 1 nil 2) (5 0 16 0 nil 0) (11 0 17 0 nil 1))) 6.130002 nil "" (om-make-point 200 200) (om-make-point 400 500)) (quote ((om-load-inputfun (quote input-funbox) "lista de CF" "list 1" nil) (om-load-inputfun (quote input-funbox) "valores a utilisar como glosa" "list 2" nil) (om-load-inputfun (quote input-funbox) "duração para compassos de material" "dur_base" nil) (om-load-inputfun (quote input-funbox) "duração minima entre valores" "dur_min" nil) (om-load-inputfun (quote input-funbox) "nº de linhas ao alto por figuração" "number of lines" nil))) (om-make-point 10 279) (om-make-point 513 66) nil nil "glosa-figur"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "glosa-figurmidi1" (om-load-patch-abs1 "glosa-figurMIDI" (quote ((let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 100))) (om-make-point 337 322) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment3" (om-make-point 333 111) (quote "Given a melodic sequence as a Cantus Firmus (CF) and a melodic sequence as an ornamentation reservoir (MS), for each two notes of the CF, this patch generates all excerpts from MS whose extreme notes form the same interval.$The resulting data is more suitable to be read by a score editor.") "" (om-make-point 625 7) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 234 151) (quote "The inputs are:$1- CF (list of MIDI)$2- Melodic sequence  (list of MIDI)$3- Length of CF notes$4- Length of each generated note$5- Number of lines (channels)$The outputs connect to a chord-seq object.$") "" (om-make-point 707 120) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment1" (om-make-point 156 64) (quote "AntÛnio de Sousa Dias$www.sousadias.com$rev. 2008") "" (om-make-point 811 347) nil (om-make-color 0.018735297 0.025613498 0.51131225) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input4" 4 (om-make-point 492 78) "nº de linhas ao alto por figuração" "number of lines" 15 nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch1" (om-load-patch-abs1 "sort_map" (quote ((let ((box (om-load-boxin "input4" 4 (om-make-point 499 45) "no documentation" "nº de linhas" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND111" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first list" "L1?" nil) (om-load-inputfun (quote input-funbox) "second list" "L2?" nil))) (om-make-point 372 320) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND11" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first list" "L1?" nil) (om-load-inputfun (quote input-funbox) "second list" "L2?" nil))) (om-make-point 280 321) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND1" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first list" "L1?" nil) (om-load-inputfun (quote input-funbox) "second list" "L2?" nil))) (om-make-point 207 316) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first list" "L1?" nil) (om-load-inputfun (quote input-funbox) "second list" "L2?" nil))) (om-make-point 126 316) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch1" (om-load-patch-abs1 "motivo glosado" (quote ((let ((box (om-load-boxin "input3" 3 (om-make-point 548 331) "no documentation" "n de linhas ao alto" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "ordena linhas" (quote ((let ((box (om-load-boxin "input3" 3 (om-make-point 420 183) "no documentation" "n de linhas" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 277 437) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 152 430) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "the list" "MATRIX" nil))) (om-make-point 217 366) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "LONSET" nil) (om-load-inputfun (quote input-funbox) "no documentation" "dur max" nil) (om-load-inputfun (quote input-funbox) "no documentation" "LMIDI" nil) (om-load-inputfun (quote input-funbox) "no documentation" "n de linhas" nil))) (om-make-point 203 284) nil nil nil (list (let ((box (om-load-boxin "input3" 3 (om-make-point 449 84) "no documentation" "n de linhas" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first list" "L1?" nil) (om-load-inputfun (quote input-funbox) "second list" "L2?" nil))) (om-make-point 263 299) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 0))) (om-make-point 263 225) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM+" (quote om+) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 0))) (om-make-point 216 256) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM//" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or tree" "SELF" 1) (om-load-inputfun (quote input-funbox) "number or tree" "DIVISOR" 1))) (om-make-point 319 229) nil nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH1" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "N" "N" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 315 169) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "N" "N" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 260 168) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "WHAT?" nil))) (om-make-point 224 355) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 1))) (om-make-point 130 98) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 60 116) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "for" (quote forloop) (quote ((om-load-inputfun (quote input-funbox) "low val" "FROM" 0) (om-load-inputfun (quote input-funbox) "high val" "TO" 10))) (om-make-point 118 144) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input2" 2 (om-make-point 351 35) "no documentation" "LMIDI" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 258 39) "no documentation" "dur max" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 145 35) "no documentation" "LONSET" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 408 369) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 37 359) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((3 0 1 0 nil 0) (4 1 1 1 nil 0) (12 0 2 0 nil 0) (4 0 2 1 nil 0) (6 0 3 0 nil 0) (2 0 3 1 nil 0) (5 0 4 0 nil 0) (0 0 4 1 nil 0) (10 0 5 0 nil 0) (11 0 5 1 nil 0) (10 0 6 0 nil 0) (13 0 6 1 nil 0) (1 0 7 0 nil 0) (9 0 8 0 nil 0) (13 0 9 0 nil 0) (8 0 10 1 nil 0) (7 1 14 0 nil 0) (7 0 15 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output1" 1 (om-make-point 378 436) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 54 438) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input2" 2 (om-make-point 291 86) "no documentation" "lchannel" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 123 86) "no documentation" "durmax" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 34 174) "no documentation" "lonset" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((3 0 1 0 nil 0) (3 0 2 0 nil 0) (4 0 3 0 nil 0) (9 0 4 0 nil 0) (8 0 4 1 nil 0) (7 0 4 2 nil 0) (0 0 4 3 nil 0) (1 0 5 0 nil 0) (2 0 6 0 nil 0))) 6.130002 nil "" (om-make-point 200 200) (om-make-point 400 500)) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "lonset" nil) (om-load-inputfun (quote input-funbox) "no documentation" "durmax" nil) (om-load-inputfun (quote input-funbox) "no documentation" "lchannel" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input3" nil))) (om-make-point 438 392) nil nil nil "ordena linhas"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*1" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 2))) (om-make-point 230 101) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT21" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "one list" "LST" nil) (om-load-inputfun (quote input-funbox) "level of parenthesis" "LEVEL" nil))) (om-make-point 236 328) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP11" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input0" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input1" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input2" nil))) (om-make-point 208 270) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 0))) (om-make-point 178 238) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "DX->X" (quote dx->x) (quote ((om-load-inputfun (quote input-funbox) "a number" "START" 0) (om-load-inputfun (quote input-funbox) "a list of numbers" "LIST" (list 1 1)))) (om-make-point 218 319) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 1))) (om-make-point 338 251) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input2" 2 (om-make-point 475 46) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 377 45) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "N" "N" 0) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 163 149) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 334 204) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "REPEAT-N" (quote repeat-n) (quote ((om-load-inputfun (quote input-funbox) "patch" "SELF" nil) (om-load-inputfun (quote input-funbox) "times" "NUM" 0))) (om-make-point 250 233) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTHCDR" (quote nthcdr) (quote ((om-load-inputfun (quote input-funbox) "N" "N" 2) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 224 148) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "WHAT?" nil))) (om-make-point 227 384) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 227 62) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 145 52) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 388 412) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 46 407) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((5 0 0 0 nil 0) (4 0 0 1 nil 0) (0 0 1 0 nil 0) (7 0 1 1 nil 0) (6 0 2 0 nil 0) (10 0 5 1 nil 0) (8 0 6 0 nil 0) (3 0 7 0 nil 0) (2 0 7 1 nil 0) (10 0 8 1 nil 0) (1 0 9 0 nil 0) (11 0 10 0 nil 0) (9 1 12 0 nil 0) (9 0 13 0 nil 0))) 1 "omloop11" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM+" (quote om+) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 2))) (om-make-point 420 481) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT2" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "one list" "LST" nil))) (om-make-point 550 253) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT1" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "one list" "LST" nil))) (om-make-point 301 352) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "REPEAT-N" (quote repeat-n) (quote ((om-load-inputfun (quote input-funbox) "patch" "SELF" nil) (om-load-inputfun (quote input-funbox) "times" "NUM" 0))) (om-make-point 360 284) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 296 200) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP1" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input0" nil))) (om-make-point 468 250) nil nil nil (list (let ((box (om-load-boxcall (quote lispfun) "NTH" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "N" "N" 1) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 198 149) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 324 199) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "REPEAT-N" (quote repeat-n) (quote ((om-load-inputfun (quote input-funbox) "patch" "SELF" nil) (om-load-inputfun (quote input-funbox) "times" "NUM" 0))) (om-make-point 221 217) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTHCDR" (quote nthcdr) (quote ((om-load-inputfun (quote input-funbox) "N" "N" 2) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 278 152) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "WHAT?" nil))) (om-make-point 210 312) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 227 62) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 145 52) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 378 317) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 44 308) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((5 0 0 1 nil 0) (3 0 1 0 nil 0) (0 0 2 0 nil 0) (1 0 2 1 nil 0) (5 0 3 1 nil 0) (2 0 4 0 nil 0) (6 0 5 0 nil 0) (4 1 7 0 nil 0) (4 0 8 0 nil 0))) 1 "omloop1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "one list" "LST" nil))) (om-make-point 41 262) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input0" nil))) (om-make-point 28 146) nil nil nil (list (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 81 150) (om-make-point 27 30) 2 "2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTHCDR" (quote nthcdr) (quote ((om-load-inputfun (quote input-funbox) "N" "N" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 116 216) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 129 121) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "WHAT?" nil))) (om-make-point 132 261) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 207 59) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 176 316) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 70 319) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((0 0 1 0 nil 0) (2 0 1 1 nil 0) (4 0 2 0 nil 0) (1 0 3 0 nil 0) (3 1 5 0 nil 0) (3 0 6 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output3" 3 (om-make-point 458 506) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output2" 2 (om-make-point 346 382) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output1" 1 (om-make-point 209 472) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 90 386) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input2" 2 (om-make-point 406 11) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 318 10) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 71 17) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((3 0 1 0 nil 0) (18 0 1 1 nil 0) (6 0 1 2 nil 0) (0 0 1 3 nil 0) (18 0 2 0 nil 0) (4 0 3 0 nil 0) (19 0 4 0 nil 0) (2 0 4 1 nil 0) (17 0 4 2 nil 0) (1 1 5 0 nil 0) (10 0 6 0 nil 0) (8 0 7 0 nil 0) (17 0 8 0 nil 0) (9 0 8 1 nil 0) (11 0 9 0 nil 0) (19 0 10 0 nil 0) (12 0 11 0 nil 0) (19 0 12 0 nil 0) (5 0 13 0 nil 0) (7 0 14 0 nil 0) (1 0 15 0 nil 0) (11 0 16 0 nil 0))) 6.130002 nil "" (om-make-point 200 200) (om-make-point 400 500)) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input1" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input2" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input3" nil))) (om-make-point 427 220) nil nil nil "motivo glosado"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "motivo CF" (quote ((let ((box (om-load-boxcall (quote bastype) "aux3" (quote t) (quote nil) (om-make-point 245 216) (om-make-point 13 28) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux2" (quote t) (quote nil) (om-make-point 227 122) (om-make-point 13 28) 2 "2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 2))) (om-make-point 198 122) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 1) (om-load-inputfun (quote input-funbox) "second input" "NUM" 1))) (om-make-point 218 213) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*1" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 100))) (om-make-point 181 253) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ARITHM-SER" (quote arithm-ser) (quote ((om-load-inputfun (quote input-funbox) "begin" "BEGIN" 0) (om-load-inputfun (quote input-funbox) "end " "END" 10) (om-load-inputfun (quote input-funbox) "step" "STEP" 1))) (om-make-point 100 189) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 316 196) (om-make-point 23 24) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "REPEAT-N1" (quote repeat-n) (quote ((om-load-inputfun (quote input-funbox) "patch" "SELF" nil) (om-load-inputfun (quote input-funbox) "times" "NUM" 0))) (om-make-point 259 229) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "REPEAT-N" (quote repeat-n) (quote ((om-load-inputfun (quote input-funbox) "patch" "SELF" nil) (om-load-inputfun (quote input-funbox) "times" "NUM" 0))) (om-make-point 327 227) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 343 117) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output3" 3 (om-make-point 352 313) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output2" 2 (om-make-point 261 313) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output1" 1 (om-make-point 156 309) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 16 311) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input2" 2 (om-make-point 327 35) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 226 18) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 21 37) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((15 0 2 0 nil 0) (1 0 2 1 nil 0) (9 0 3 0 nil 0) (0 0 3 1 nil 0) (5 0 4 0 nil 0) (2 0 4 1 nil 0) (3 0 5 1 nil 0) (2 0 7 0 nil 0) (9 0 7 1 nil 0) (6 0 8 0 nil 0) (9 0 8 1 nil 0) (16 0 9 0 nil 0) (8 0 10 0 nil 0) (7 0 11 0 nil 0) (4 0 12 0 nil 0) (16 0 13 0 nil 0))) 6.130002 nil "" (om-make-point 200 200) (om-make-point 400 500)) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input1" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input2" nil))) (om-make-point 140 208) nil nil nil "motivo CF"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output3" 3 (om-make-point 377 389) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) "lchannels" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output2" 2 (om-make-point 270 391) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) "ldurs" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output1" 1 (om-make-point 193 385) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) "lonsets" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 111 388) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) "lmidicents" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input3" 3 (om-make-point 400 9) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input2" 2 (om-make-point 302 35) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 217 60) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 105 95) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((6 3 1 0 nil 0) (5 3 1 1 nil 0) (6 2 2 0 nil 0) (5 2 2 1 nil 0) (6 1 3 0 nil 0) (5 1 3 1 nil 0) (6 0 4 0 nil 0) (5 0 4 1 nil 0) (13 0 5 0 nil 0) (12 0 5 1 nil 0) (11 0 5 2 nil 0) (0 0 5 3 nil 0) (14 0 6 0 nil 0) (12 0 6 1 nil 0) (11 0 6 2 nil 0) (1 0 7 0 nil 0) (2 0 8 0 nil 0) (3 0 9 0 nil 0) (4 0 10 0 nil 0))) 6.130002 nil "" (om-make-point 200 200) (om-make-point 400 500)) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input1" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input2" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input3" nil) (om-load-inputfun (quote input-funbox) "no documentation" "nº de linhas" nil))) (om-make-point 287 255) (om-make-point 294 63) nil "&" "sort_map"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output4" 4 (om-make-point 495 362) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) "lchannels" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input3" 3 (om-make-point 462 40) "duração minima entre valores" "dur_min" 125 nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input2" 2 (om-make-point 411 9) "duração para compassos de material" "dur_base" 2000 nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP2" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input0" nil))) (om-make-point 49 141) nil nil "&" (list (let ((box (om-load-boxcall (quote lispfun) "REMOVE1" (quote remove) (quote ((om-load-inputfun (quote input-funbox) "ITEM" "ITEM" nil) (om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 297 286) nil nil nil "remove" 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux1" (quote t) (quote nil) (om-make-point 342 114) (om-make-point 61 26) (quote lista_base) "lista_base" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "EVAL" (quote eval) (quote ((om-load-inputfun (quote input-funbox) "FORM" "FORM" nil))) (om-make-point 356 168) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "SEQUENCE" (quote sequence) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil) (om-load-inputfun (quote input-funbox) "patch" "OPPATCH" nil))) (om-make-point 293 240) nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "remove_l_dups" (om-load-patch-abs1 "remove_l_dups" (quote ((let ((box (om-load-boxin "input1" 1 (om-make-point 183 21) "no documentation" "nome variavel" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "ARG-0" "ARG-0" nil))) (om-make-point 2 148) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM>" (quote om>) (quote ((om-load-inputfun (quote input-funbox) "a number" "SELF" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM" 1))) (om-make-point 46 185) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "if" "TEST" nil) (om-load-inputfun (quote input-funbox) "then" "ACTION" nil) (om-load-inputfun (quote input-funbox) "else" "ELSE" nil))) (om-make-point 78 210) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "lista de listas" nil) (om-load-inputfun (quote input-funbox) "no documentation" "nome_variavel" nil))) (om-make-point 157 125) nil nil nil (list (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input0" nil) (om-load-inputfun (quote input-funbox) "no documentation" "lista de listas" nil) (om-load-inputfun (quote input-funbox) "no documentation" "nome de variavel" nil))) (om-make-point 219 182) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "WHAT?" nil))) (om-make-point 174 330) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "compare_elements" (quote ((let ((box (om-load-boxcall (quote lispfun) "LIST" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 449 147) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "SET" (quote set) (quote ((om-load-inputfun (quote input-funbox) "SYMBOL" "SYMBOL" nil) (om-load-inputfun (quote input-funbox) "VALUE" "VALUE" nil))) (om-make-point 388 269) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "EVAL" (quote eval) (quote ((om-load-inputfun (quote input-funbox) "FORM" "FORM" nil))) (om-make-point 414 170) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "SUBS-POSN" (quote subs-posn) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIS1" (list 0 1 2 3)) (om-load-inputfun (quote input-funbox) " a list of indexes" "POSN" (list 1 3)) (om-load-inputfun (quote input-funbox) "a list" "VAL" (list nil)))) (om-make-point 434 221) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF1" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "if" "TEST" nil) (om-load-inputfun (quote input-funbox) "then" "ACTION" nil))) (om-make-point 310 345) (om-make-point 131 53) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMAND" (quote omand) (quote ((om-load-inputfun (quote input-funbox) "patch" "SELF" nil) (om-load-inputfun (quote input-funbox) "add patch" "REST" nil))) (om-make-point 309 303) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=11" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "SELF" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM" 0))) (om-make-point 322 232) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=1" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "SELF" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM" 0))) (om-make-point 271 233) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "LIST-MAX" (quote list-max) (quote ((om-load-inputfun (quote input-funbox) "a list" "SELF" (list 0 1 2)))) (om-make-point 330 182) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "LIST-MIN" (quote list-min) (quote ((om-load-inputfun (quote input-funbox) "a list" "SELF" (list 0 1 2)))) (om-make-point 270 182) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "if" "TEST" nil) (om-load-inputfun (quote input-funbox) "then" "ACTION" nil))) (om-make-point 232 398) (om-make-point 131 53) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "SELF" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM" 0))) (om-make-point 142 261) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 0))) (om-make-point 266 137) (om-make-point 78 27) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH1" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 149 149) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 103 149) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH1" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "N" "N" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 158 102) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "N" "N" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 95 103) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 282 460) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input3" 3 (om-make-point 405 17) "no documentation" "nome variavel" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input2" 2 (om-make-point 259 43) "no documentation" "lista de listas" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 147 12) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 91 17) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((20 0 0 0 nil 0) (18 0 1 0 nil 0) (3 0 1 1 nil 0) (18 0 2 0 nil 0) (2 0 3 0 nil 0) (0 0 3 1 nil 0) (5 0 4 0 nil 0) (1 0 4 1 nil 0) (7 0 5 0 nil 0) (6 0 5 1 nil 0) (8 0 6 0 nil 0) (9 0 7 0 nil 0) (12 0 8 0 nil 0) (12 0 9 0 nil 0) (11 0 10 0 nil 0) (4 0 10 1 nil 0) (14 0 11 0 nil 0) (13 0 11 1 nil 0) (16 0 12 0 nil 0) (15 0 12 1 nil 0) (15 0 13 0 nil 0) (16 0 14 0 nil 0) (20 0 15 0 nil 0) (19 0 15 1 nil 0) (21 0 16 0 nil 0) (19 0 16 1 nil 0) (10 0 17 0 nil 0))) 6.130002 nil "" (om-make-point 200 200) (om-make-point 400 500)) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input1" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input2" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input3" nil))) (om-make-point 31 236) (om-make-point 353 61) nil nil "compare_elements"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM+" (quote om+) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 1))) (om-make-point 110 113) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "for" (quote forloop) (quote ((om-load-inputfun (quote input-funbox) "low val" "FROM" 0) (om-load-inputfun (quote input-funbox) "high val" "TO" 10))) (om-make-point 128 174) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "ARG-0" "ARG-0" nil))) (om-make-point 147 118) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 2))) (om-make-point 183 156) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux3" (quote t) (quote nil) (om-make-point 186 127) (om-make-point 11 20) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input2" 2 (om-make-point 349 31) "no documentation" "nome de variavel" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 234 30) "no documentation" "lista de listas" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 5 40) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 320 301) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 43 309) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((1 0 0 0 nil 0) (9 0 1 0 nil 0) (3 0 1 1 nil 0) (8 0 1 2 nil 0) (7 0 1 3 nil 0) (9 0 2 0 nil 0) (2 0 3 0 nil 0) (5 0 3 1 nil 0) (8 0 4 0 nil 0) (4 0 5 0 nil 0) (6 0 5 1 nil 0) (0 1 10 0 nil 0) (0 0 11 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "WHAT?" nil))) (om-make-point 211 293) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "ARG-0" "ARG-0" nil))) (om-make-point 43 112) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 2))) (om-make-point 79 150) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux3" (quote t) (quote nil) (om-make-point 147 96) (om-make-point 18 28) 2 "2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "for" (quote forloop) (quote ((om-load-inputfun (quote input-funbox) "low val" "FROM" 0) (om-load-inputfun (quote input-funbox) "high val" "TO" 10))) (om-make-point 127 162) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 392 44) "no documentation" "nome_variavel" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 50 42) "no documentation" "lista de listas" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 332 314) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 46 317) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((5 0 0 0 nil 0) (7 0 0 1 nil 0) (6 0 0 2 nil 0) (0 0 1 0 nil 0) (7 0 2 0 nil 0) (2 0 3 0 nil 0) (4 0 3 1 nil 0) (3 0 5 1 nil 0) (1 1 8 0 nil 0) (1 0 9 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "SET" (quote set) (quote ((om-load-inputfun (quote input-funbox) "ARG-0" "ARG-0" nil) (om-load-inputfun (quote input-funbox) "ARG-1" "ARG-1" nil))) (om-make-point 51 75) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 53 314) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) "lista_s_dups" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 51 6) "lista" "lista de listas" (list nil) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((5 0 1 0 nil 0) (1 0 2 0 nil 0) (2 0 3 0 nil 0) (4 0 3 1 nil 0) (5 0 3 2 nil 0) (5 0 4 0 nil 0) (0 0 4 1 nil 0) (0 0 5 0 nil 0) (7 0 5 1 nil 0) (3 0 6 0 nil 0))) 6.130002 nil "" (om-make-point 200 200) (om-make-point 400 500)) (quote ((om-load-inputfun (quote input-funbox) "lista" "lista" (list nil)) (om-load-inputfun (quote input-funbox) "no documentation" "input1" nil))) (om-make-point 225 151) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "WHAT?" nil))) (om-make-point 182 342) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 129 108) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 137 43) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 299 360) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 93 359) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((3 1 0 1 nil 0) (1 0 2 0 nil 0) (4 0 3 0 nil 0) (2 0 3 1 nil 0) (6 0 4 0 nil 0) (1 0 4 1 nil 0) (0 0 5 0 nil 0) (7 0 6 0 nil 0) (5 1 8 0 nil 0) (5 0 9 0 nil 0))) 1 "remover listas dups" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 261 162) (om-make-point 17 24) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "one list" "LST" nil) (om-load-inputfun (quote input-funbox) "level of parenthesis" "LEVEL" nil))) (om-make-point 214 177) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output3" 3 (om-make-point 448 363) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) "ldurs" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP1" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input0" nil))) (om-make-point 53 207) nil nil "&" (list (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input0" nil))) (om-make-point 114 134) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first list" "L1?" nil) (om-load-inputfun (quote input-funbox) "second list" "L2?" nil) (om-load-inputfun (quote input-funbox) "add list" "LST?" nil))) (om-make-point 234 263) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CDR" (quote cdr) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 333 225) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CAR" (quote car) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 287 195) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "N" "N" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 347 173) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 184 59) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 1))) (om-make-point 153 78) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "for" (quote forloop) (quote ((om-load-inputfun (quote input-funbox) "low val" "FROM" 0) (om-load-inputfun (quote input-funbox) "high val" "TO" 10))) (om-make-point 138 123) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "WHAT?" nil))) (om-make-point 225 317) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 255 34) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 350 305) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 53 302) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((2 0 0 0 nil 0) (6 0 0 1 nil 0) (1 0 0 2 nil 0) (3 0 1 0 nil 0) (3 0 2 0 nil 0) (6 0 3 0 nil 0) (8 0 3 1 nil 0) (8 0 4 0 nil 0) (4 0 5 0 nil 0) (5 0 6 1 nil 0) (0 0 7 0 nil 0) (7 1 9 0 nil 0) (7 0 10 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "WHAT?" nil))) (om-make-point 215 178) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 208 78) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 124 40) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 335 253) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 76 260) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((2 0 0 0 nil 0) (0 0 1 0 nil 0) (3 0 2 0 nil 0) (1 1 4 0 nil 0) (1 0 5 0 nil 0))) 1 "inserir canal midi" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output2" 2 (om-make-point 383 362) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) "lonsets" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "list (E d)" (quote ((let ((box (om-load-boxcomment "comment" (om-make-point 145 120) (quote "Outputs a list of lists containing:$((note$intervToNextNote$index)$...$)") "" (om-make-point 204 385) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST1" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 0 331) (om-make-point 168 39) nil nil "list" 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 1))) (om-make-point 204 191) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ARITHM-SER" (quote arithm-ser) (quote ((om-load-inputfun (quote input-funbox) "begin" "BEGIN" 0) (om-load-inputfun (quote input-funbox) "end " "END" 10) (om-load-inputfun (quote input-funbox) "step" "STEP" 1))) (om-make-point 184 255) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "the list" "MATRIX" nil))) (om-make-point 54 377) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X->DX" (quote x->dx) (quote ((om-load-inputfun (quote input-funbox) "a list of numbers" "SELF" 0))) (om-make-point 58 188) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first list" "L1?" nil) (om-load-inputfun (quote input-funbox) "second list" "L2?" nil))) (om-make-point 52 132) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FIRST-N" (quote first-n) (quote ((om-load-inputfun (quote input-funbox) "one list" "LIST" nil) (om-load-inputfun (quote input-funbox) "number of elements" "N" 0))) (om-make-point 138 185) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 195 127) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 62 443) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 29 34) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((10 0 1 0 nil 0) (7 0 1 1 nil 0) (3 0 1 2 nil 0) (8 0 2 0 nil 0) (2 0 3 1 nil 0) (1 0 4 0 nil 0) (6 0 5 0 nil 0) (10 0 6 0 nil 0) (10 0 6 1 nil 0) (5 0 7 0 nil 0) (8 0 7 1 nil 0) (10 0 8 0 nil 0) (4 0 9 0 nil 0))) 6.130002 nil "" (om-make-point 200 200) (om-make-point 400 500)) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input" nil))) (om-make-point 13 71) nil nil nil "list (E d)"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "list_1" nil) (om-load-inputfun (quote input-funbox) "no documentation" "list_2" nil))) (om-make-point 82 79) nil nil "&" (list (let ((box (om-load-boxcomment "comment" (om-make-point 100 40) (quote "duplicate list to circulation") "" (om-make-point 432 77) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 272 156) (om-make-point 35 32) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "one list" "LST" nil) (om-load-inputfun (quote input-funbox) "level of parenthesis" "LEVEL" nil))) (om-make-point 234 219) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment1" (om-make-point 73 27) (quote "list to study") "" (om-make-point 466 26) nil (om-make-color 0 0 0) (om-make-font "Geneva" 10 :family "Geneva" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 136 58) (quote "(note$interval to next note$index)") "" (om-make-point 125 65) nil (om-make-color 0 0 0) (om-make-font "Geneva" 10 :family "Geneva" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first list" "L1?" nil) (om-load-inputfun (quote input-funbox) "second list" "L2?" nil))) (om-make-point 364 61) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "lista 1" nil) (om-load-inputfun (quote input-funbox) "no documentation" "lista 2" nil))) (om-make-point 223 149) nil nil nil (list (let ((box (om-load-boxcomment "comment2" (om-make-point 136 58) (quote "(note$interval to next note$index)") "" (om-make-point 32 137) nil (om-make-color 0 0 0) (om-make-font "Geneva" 10 :family "Geneva" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment11" (om-make-point 73 27) (quote "list to study") "" (om-make-point 402 17) nil (om-make-color 0 0 0) (om-make-font "Geneva" 10 :family "Geneva" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 309 93) (om-make-point 14 27) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 94 21) (quote "first for loop") "" (om-make-point 358 138) nil (om-make-color 0 0 0) (om-make-font "Geneva" 10 :family "Geneva" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input0" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input1" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input2" nil))) (om-make-point 172 172) nil nil nil (list (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 503 279) (om-make-point 29 38) 2 "2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "one list" "LST" nil) (om-load-inputfun (quote input-funbox) "level of parenthesis" "LEVEL" nil))) (om-make-point 445 344) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "if" "TEST" nil) (om-load-inputfun (quote input-funbox) "then" "ACTION" nil))) (om-make-point 225 451) (om-make-point 145 53) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 94 21) (quote "second for loop") "" (om-make-point 475 234) nil (om-make-color 0 0 0) (om-make-font "Geneva" 10 :family "Geneva" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch1" (om-load-patch-abs1 "fabrica" (quote ((let ((box (om-load-boxcall (quote abstraction) "mypatch1" (om-load-patch-abs1 "intervalos reduzidos" (quote ((let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "SELF" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM" 0))) (om-make-point 186 182) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 265 31) (om-make-point 45 33) 12 "12" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM//1" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or tree" "SELF" 1) (om-load-inputfun (quote input-funbox) "number or tree" "DIVISOR" 1))) (om-make-point 245 156) (om-make-point 33 53) nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM//" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or tree" "SELF" 1) (om-load-inputfun (quote input-funbox) "number or tree" "DIVISOR" 1))) (om-make-point 139 97) nil nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 212 261) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 208 89) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 102 16) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((3 1 0 0 nil 0) (2 1 0 1 nil 0) (5 0 2 0 nil 0) (1 0 2 1 nil 0) (6 0 3 0 nil 0) (1 0 3 1 nil 0) (0 0 4 0 nil 0))) 6.130002 nil "" (om-make-point 200 200) (om-make-point 400 500)) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input1" nil))) (om-make-point 109 317) nil nil nil "intervalos reduzidos"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMOR" (quote omor) (quote ((om-load-inputfun (quote input-funbox) "patch" "SELF" nil) (om-load-inputfun (quote input-funbox) "add patch" "REST" nil))) (om-make-point 64 388) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 80 40) (quote "compara intervalos") "" (om-make-point 85 452) nil (om-make-color 0 0 0) (om-make-font "Geneva" 10 :family "Geneva" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output1" 1 (om-make-point 375 410) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "make sequence" (quote ((let ((box (om-load-boxcall (quote lispfun) "NTH2" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "N" "N" 0) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 105 106) nil nil nil "nth" 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "DX->X" (quote dx->x) (quote ((om-load-inputfun (quote input-funbox) "a number" "START" 0) (om-load-inputfun (quote input-funbox) "a list of numbers" "LIST" (list 1 1)))) (om-make-point 110 163) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ARITHM-SER" (quote arithm-ser) (quote ((om-load-inputfun (quote input-funbox) "begin" "BEGIN" 0) (om-load-inputfun (quote input-funbox) "end " "END" 10) (om-load-inputfun (quote input-funbox) "step" "STEP" 1))) (om-make-point 348 130) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "POSN-MATCH" (quote posn-match) (quote ((om-load-inputfun (quote input-funbox) "list" "LIST" (list 10 20 30 40 50 60 70 80 90)) (om-load-inputfun (quote input-funbox) "positions" "POSITIONS" (list (list 0 1) 4 (list 6))))) (om-make-point 298 211) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X->DX" (quote x->dx) (quote ((om-load-inputfun (quote input-funbox) "a list of numbers" "SELF" 0))) (om-make-point 153 101) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH111" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "N" "N" 2) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 40 108) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first list" "L1?" nil) (om-load-inputfun (quote input-funbox) "second list" "L2?" nil))) (om-make-point 52 317) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input3" 3 (om-make-point 402 18) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 307 325) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input2" 2 (om-make-point 335 18) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 239 6) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 85 6) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((11 0 0 1 nil 0) (0 0 1 0 nil 0) (4 0 1 1 nil 0) (9 0 2 0 nil 0) (7 0 2 1 nil 0) (10 0 3 0 nil 0) (2 0 3 1 nil 0) (3 0 4 0 nil 0) (11 0 5 1 nil 0) (5 0 6 0 nil 0) (1 0 6 1 nil 0) (6 0 8 0 nil 0))) 6.130002 nil "" (om-make-point 200 200) (om-make-point 400 500)) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input1" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input2" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input3" nil))) (om-make-point 354 300) nil nil nil "make sequence"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "one list" "LST" nil))) (om-make-point 154 28) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 24 439) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "SELF" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM" 0))) (om-make-point 19 338) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH11" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "N" "N" 1) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 21 245) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 0))) (om-make-point 142 256) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH1" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "N" "N" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 196 152) nil nil nil "nth" 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "N" "N" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 127 113) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input3" 3 (om-make-point 454 65) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input2" 2 (om-make-point 223 5) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 82 15) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 41 153) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((8 0 0 0 nil 0) (9 0 0 1 nil 0) (7 0 1 0 nil 0) (0 0 1 1 nil 0) (4 0 3 0 nil 0) (15 0 4 0 nil 2) (14 0 4 1 nil 1) (13 0 4 2 nil 0) (12 0 4 3 nil 3) (14 0 5 0 nil 1) (1 0 6 0 nil 0) (8 0 7 0 nil 0) (9 0 7 1 nil 0) (15 0 8 1 nil 2) (10 0 9 0 nil 1) (11 0 9 1 nil 0) (12 0 10 0 nil 3) (5 0 10 1 nil 1) (13 0 11 0 nil 0) (5 0 11 1 nil 1))) 6.130002 nil "" (om-make-point 200 200) (om-make-point 400 500)) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input1" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input2" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input3" nil))) (om-make-point 156 282) (om-make-point 171 63) nil nil "fabrica"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "WHAT?" nil))) (om-make-point 455 408) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "lenght/2-1" (quote ((let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 1))) (om-make-point 218 69) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM//" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or tree" "SELF" 1) (om-load-inputfun (quote input-funbox) "number or tree" "DIVISOR" 2))) (om-make-point 157 65) nil nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 89 72) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 281 68) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 29 53) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (2 0 1 0 nil 0) (4 0 2 0 nil 0) (0 0 3 0 nil 0))) 6.130002 nil "" (om-make-point 200 200) (om-make-point 400 500)) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input" nil))) (om-make-point 548 91) nil nil nil "lenght/2-1"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM+1" (quote om+) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 1))) (om-make-point 511 176) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM+" (quote om+) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 1))) (om-make-point 456 124) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "for" (quote forloop) (quote ((om-load-inputfun (quote input-funbox) "low val" "FROM" 0) (om-load-inputfun (quote input-funbox) "high val" "TO" 10))) (om-make-point 425 229) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input2" 2 (om-make-point 357 102) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 235 44) "no documentation" nil nil (om-make-point 41 53)))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 145 41) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 450 501) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 274 517) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((4 1 1 0 nil 0) (0 0 1 1 nil 0) (4 0 2 0 nil 0) (5 0 2 1 nil 0) (12 0 4 0 nil 2) (11 0 4 1 nil 1) (10 0 4 2 nil 0) (9 0 4 3 nil 0) (1 0 5 0 nil 0) (11 0 6 0 nil 1) (8 0 7 0 nil 0) (6 0 7 1 nil 0) (10 0 8 0 nil 0) (8 0 9 0 nil 0) (7 0 9 1 nil 0) (5 1 13 0 nil 0) (2 0 14 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "lenght/2-1" (quote ((let ((box (om-load-boxcall (quote bastype) "aux1" (quote t) (quote nil) (om-make-point 224 24) (om-make-point 13 28) 2 "2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 263 98) (om-make-point 13 28) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "one list" "LST" nil))) (om-make-point 87 57) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 1))) (om-make-point 231 134) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM//" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or tree" "SELF" 1) (om-load-inputfun (quote input-funbox) "number or tree" "DIVISOR" 2))) (om-make-point 208 54) nil nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 147 58) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 324 119) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 29 53) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((7 0 2 0 nil 0) (4 0 3 0 nil 0) (1 0 3 1 nil 0) (5 0 4 0 nil 0) (0 0 4 1 nil 0) (2 0 5 0 nil 0) (3 0 6 0 nil 0))) 6.130002 nil "" (om-make-point 200 200) (om-make-point 400 500)) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input" nil))) (om-make-point 406 67) nil nil nil "lenght/2-1"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "for" (quote forloop) (quote ((om-load-inputfun (quote input-funbox) "low val" "FROM" 0) (om-load-inputfun (quote input-funbox) "high val" "TO" 10))) (om-make-point 314 127) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "WHAT?" nil))) (om-make-point 176 302) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 251 32) "no documentation" "lista 2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 60 40) "no documentation" "lista 1" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 258 331) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 87 337) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((9 0 4 0 nil 2) (8 0 4 1 nil 1) (6 0 4 2 nil 0) (8 0 5 0 nil 0) (2 0 6 0 nil 0) (5 0 6 1 nil 0) (4 0 7 0 nil 0) (7 1 10 0 nil 0) (7 0 11 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 78 61) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "WHAT?" nil))) (om-make-point 336 198) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 419 2) "no documentation" "list_2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 5 40) "no documentation" "list_1" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 379 273) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 299 273) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((6 0 2 0 nil 0) (1 0 2 1 nil 0) (9 0 5 0 nil 0) (9 0 5 1 nil 0) (7 0 6 0 nil 0) (5 0 6 1 nil 0) (10 0 7 0 nil 0) (2 0 8 0 nil 0) (8 1 11 0 nil 0) (8 0 12 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output1" 1 (om-make-point 327 363) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) "lmidic" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 194 321) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) "output lists" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 362 7) "valores a utilisar como glosa" "list 2" (list 65 66 63 62) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 296 7) "lista de CF" "list 1" (list 60 71 63 74) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((5 0 0 0 nil 0) (20 0 5 0 nil 0) (11 0 5 1 nil 1) (8 0 5 2 nil 0) (7 0 5 3 nil 0) (4 0 5 4 nil 0) (5 3 6 0 nil 0) (16 0 9 0 nil 0) (13 0 11 0 nil 0) (10 0 11 1 nil 0) (5 2 12 0 nil 0) (9 0 13 0 nil 0) (5 1 14 0 nil 0) (20 0 15 0 nil 0) (15 0 16 0 nil 0) (19 0 16 1 nil 2) (0 0 17 0 nil 0) (11 0 18 0 nil 1))) 6.130002 nil "" (om-make-point 200 200) (om-make-point 400 500)) (quote ((om-load-inputfun (quote input-funbox) "lista de CF" "list 1" (list 60 71 63 74)) (om-load-inputfun (quote input-funbox) "valores a utilisar como glosa" "list 2" (list 65 66 63 62)) (om-load-inputfun (quote input-funbox) "duração para compassos de material" "dur_base" 2000) (om-load-inputfun (quote input-funbox) "duração minima entre valores" "dur_min" 125) (om-load-inputfun (quote input-funbox) "nº de linhas ao alto por figuração" "number of lines" 15))) (om-make-point 559 278) (om-make-point 429 66) nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment2" (om-make-point 119 27) (quote "Enter midi values") "" (om-make-point 617 250) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 151 28) (quote "Enter midicent values") "" (om-make-point 89 225) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "SAVE-AS-MIDI" (quote save-as-midi) (quote ((om-load-inputfun (quote input-funbox) "a music object to save" "OBJECT" nil))) (om-make-point 606 549) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD-SEQ11" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "objs" "SELF" nil) (om-load-inputfun (quote input-funbox) "LMIDIC" "LMIDIC" (list 6000)) (om-load-inputfun (quote input-funbox) "LONSET" "LONSET" (list 0 1000)) (om-load-inputfun (quote input-funbox) "LDUR" "LDUR" (list 1000)) (om-load-inputfun (quote input-funbox) "LVEL" "LVEL" (list 100)) (om-load-inputfun (quote input-funbox) "LOFFSET" "LOFFSET" (list 0)) (om-load-inputfun (quote input-funbox) "LCHAN" "LCHAN" (list 1)) (om-load-inputfun (quote input-funbox) "LEGATO" "LEGATO" 0))) (om-make-point 592 357) (om-make-point 470 189) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6500) (6400) (7200) (7300) (6500) (6400) (6500) (6400) (7200) (7100) (6900) (6800) (7200) (6800) (7500) (6400) (6500) (7300) (7200) (7000) (6900) (7300) (6900) (7600) (6500) (6400) (6800) (6400) (6500) (6400) (6800) (6400) (7100) (6000) (6300) (6400) (6500) (6900) (6500) (7200) (6100) (6400) (6500) (6100) (6800) (5700) (6000) (6100) (5800) (5700) (6500) (6400) (6500) (7200) (6100) (6400) (6500) (6800) (6900) (6600) (6500) (7300) (7200) (7000) (6900) (7300) (6900) (7600) (6500) (6200) (6100) (6900) (6800) (6600) (6500) (6900) (6500) (7200) (6100) (6400) (6400) (7200) (6400) (7200) (7100) (6900) (6800) (7200) (6400) (6300) (6100) (6000) (6400) (6300) (6100) (6000) (6400) (6000) (6400) (6300) (6100) (6000) (6400) (6000) (6700) (5600) (5900) (6000) (6400) (6200) (6100) (6500) (6100) (6800) (5700) (6000) (6400) (6300) (6700) (6300) (7000) (5900) (6200) (6300) (6000) (6400) (6800) (6400) (7100) (6000) (6400) (6800) (6400) (7100) (6000) (6300) (6400) (6100) (6000) (6400) (6000) (6400) (6000) (6700) (5600) (5900) (6000) (6400) (6000) (6700) (5600) (5900) (6000) (5700) (5600) (6400) (6300) (6100) (6000) (6400) (7100) (6000) (6400) (7100) (6000) (6300) (6400) (6100) (6000) (6400) (5300) (5600) (5700) (5400) (5300) (6100) (6000) (6400) (6700) (6800) (6500) (6400) (7200) (6400) (6700) (6800) (6500) (6400) (7200) (7100) (6900) (6800) (7200) (6400) (6500) (6200) (6100) (6900) (6800) (6600) (6500) (6900) (6500) (7200) (6400) (6100) (6000) (6400) (6100) (6000) (6800) (6700) (6500) (6400) (6800) (6400) (7100) (6000) (7200) (8000) (7900) (7700) (7600) (8000) (7600) (8300) (7200) (7500) (7600) (7300) (7200) (7000) (6900) (7300) (7200) (7000) (6900) (7300) (6900) (7600) (6500) (6800) (6900) (6600) (6500) (7300) (7200) (7600) (7200) (7900) (6800) (7100) (7200) (6900) (6800) (7600) (7500) (7300) (7200) (7900) (6800) (7100) (7200) (6900) (6800) (7600) (7500) (7300) (7200) (6100) (7200) (6100) (6400) (6500) (6200) (6100) (7200) (7500) (7600) (7300) (7200) (7300) (7200) (7300) (7000) (6900) (7700) (7600) (7400) (7300) (7200) (7300) (7000) (6900) (7700) (7600) (7400) (7300) (7700) (7300) (7200) (6900) (6800) (7600) (7500) (7300) (7300) (7200) (8000) (7900) (7700) (7300) (8100) (8000) (7800) (7700) (7300) (8100) (8000) (7800) (7700) (8100) (7700) (7300) (8100) (8000) (7800) (7700) (8100) (7700) (8400) (7300) (7600) (7700) (7300) (7200) (7000) (6900) (7300) (6900) (7600) (6500) (7300) (7200) (7000) (6900) (7300) (6900) (7600) (6500) (6800) (6900) (6600) (6500) (7300) (7100) (7000) (7400) (7000) (7700) (7300) (7700) (7300) (7700) (7300) (8000) (6900) (7200) (7300) (7000) (6900) (7700) (7300) (6900) (7600) (6500) (7300) (6900) (7600) (6500) (6800) (6900) (6600) (6500) (7300) (8000) (6900) (7200) (7300) (7000) (6900) (7700) (7300) (8000) (6900) (7200) (7300) (7000) (6900) (7700) (7600) (7400) (7300) (7700) (7300) (6200) (6500) (7300) (7600) (7700) (7300) (7600) (7700) (7400) (7300) (8100) (8000) (7800) (7700) (7300) (7600) (7700) (7400) (7300) (8100) (8000) (7800) (7700) (8100) (7700) (7300) (7400) (7100) (7000) (7800) (7700) (7300) (7000) (6900) (7700) (7300) (7000) (6900) (7700) (7600) (7400) (7300) (7700))) :lonset (quote (0 8000 16000 24000 0 125 0 125 250 375 500 625 750 875 1000 1125 0 125 250 375 500 625 750 875 0 125 250 375 0 125 250 375 500 625 750 875 0 125 250 375 500 625 0 125 250 375 500 625 750 875 1000 1125 0 125 250 375 0 125 250 375 500 625 750 875 1000 1125 1250 1375 0 125 250 375 500 625 750 875 1000 1125 1250 1375 8000 8125 8000 8125 8250 8375 8500 8625 8000 8125 8250 8375 8000 8125 8250 8375 8500 8625 8000 8125 8250 8375 8500 8625 8750 8875 9000 9125 8000 8125 8250 8375 8500 8625 8750 8875 8000 8125 8250 8375 8500 8625 8750 8875 9000 8000 8125 8250 8375 8500 8000 8125 8250 8375 8500 8625 8750 8875 9000 8000 8125 8000 8125 8250 8375 8500 8625 8000 8125 8250 8375 8500 8625 8750 8875 9000 9125 9250 9375 8000 8125 8250 8000 8125 8250 8375 8500 8625 8750 12000 12125 12250 12375 12500 12625 12750 12875 12000 12125 12250 12375 12500 12625 12000 12125 12250 12375 12500 12625 12750 12875 13000 13125 12000 12125 12250 12375 12500 12625 12750 12875 13000 13125 13250 12000 12125 12250 12000 12125 12250 12375 12500 12625 12750 12875 13000 13125 13250 16000 16125 16250 16375 16500 16625 16750 16875 17000 17125 17250 17375 16000 16125 16250 16375 16000 16125 16250 16375 16500 16625 16750 16875 17000 17125 17250 17375 16000 16125 16250 16375 16500 16625 16750 16875 17000 17125 17250 17375 16000 16125 16250 16375 16500 16625 16750 16875 17000 17125 16000 16125 16000 16125 16250 16375 16500 16625 16000 16125 16250 16375 16000 16125 16000 16125 16250 16375 16500 16625 16750 16875 16000 16125 16250 16375 16500 16625 16750 16875 17000 17125 16000 16125 16250 16375 16500 16625 24000 24125 24250 24375 24500 24000 24125 24250 24375 24500 24000 24125 24250 24375 24500 24625 24750 24000 24125 24250 24375 24500 24625 24750 24875 25000 25125 25250 24000 24125 24250 24375 24500 24625 24750 24875 24000 24125 24250 24375 24500 24625 24750 24875 25000 25125 25250 25375 24000 24125 24250 24375 24500 24625 24000 24125 24000 24125 24250 24375 24500 24625 24750 24875 25000 25125 24000 24125 24250 24375 24000 24125 24250 24375 24500 24625 24750 24875 24000 24125 24250 24375 24500 24625 24750 24875 24000 24125 24250 24375 24500 24625 24750 24875 25000 25125 25250 25375 24000 24125 24250 28000 28125 28250 28000 28125 28250 28375 28500 28625 28750 28875 29000 28000 28125 28250 28375 28500 28625 28750 28875 29000 29125 29250 28000 28125 28250 28375 28500 28625 28000 28125 28250 28375 28000 28125 28250 28375 28500 28625 28750 28875 32000)) :ldur (quote ((8000) (8000) (8000) (8000) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (2) (2) (3) (3) (3) (3) (3) (3) (3) (3) (3) (3) (4) (4) (4) (4) (4) (4) (4) (4) (5) (5) (5) (5) (6) (6) (6) (6) (6) (6) (6) (6) (7) (7) (7) (7) (7) (7) (8) (8) (8) (8) (8) (8) (8) (8) (8) (8) (9) (9) (9) (9) (10) (10) (10) (10) (10) (10) (10) (10) (10) (10) (10) (10) (11) (11) (11) (11) (11) (11) (11) (11) (11) (11) (11) (11) (2) (2) (3) (3) (3) (3) (3) (3) (4) (4) (4) (4) (5) (5) (5) (5) (5) (5) (6) (6) (6) (6) (6) (6) (6) (6) (6) (6) (7) (7) (7) (7) (7) (7) (7) (7) (8) (8) (8) (8) (8) (8) (8) (8) (8) (9) (9) (9) (9) (9) (10) (10) (10) (10) (10) (10) (10) (10) (10) (11) (11) (12) (12) (12) (12) (12) (12) (13) (13) (13) (13) (13) (13) (13) (13) (13) (13) (13) (13) (14) (14) (14) (15) (15) (15) (15) (15) (15) (15) (2) (2) (2) (2) (2) (2) (2) (2) (3) (3) (3) (3) (3) (3) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (5) (5) (5) (5) (5) (5) (5) (5) (5) (5) (5) (6) (6) (6) (7) (7) (7) (7) (7) (7) (7) (7) (7) (7) (7) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (3) (3) (3) (3) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (5) (5) (5) (5) (5) (5) (5) (5) (5) (5) (5) (5) (6) (6) (6) (6) (6) (6) (6) (6) (6) (6) (7) (7) (8) (8) (8) (8) (8) (8) (9) (9) (9) (9) (10) (10) (11) (11) (11) (11) (11) (11) (11) (11) (12) (12) (12) (12) (12) (12) (12) (12) (12) (12) (13) (13) (13) (13) (13) (13) (2) (2) (2) (2) (2) (3) (3) (3) (3) (3) (4) (4) (4) (4) (4) (4) (4) (5) (5) (5) (5) (5) (5) (5) (5) (5) (5) (5) (6) (6) (6) (6) (6) (6) (6) (6) (7) (7) (7) (7) (7) (7) (7) (7) (7) (7) (7) (7) (8) (8) (8) (8) (8) (8) (9) (9) (10) (10) (10) (10) (10) (10) (10) (10) (10) (10) (11) (11) (11) (11) (12) (12) (12) (12) (12) (12) (12) (12) (13) (13) (13) (13) (13) (13) (13) (13) (14) (14) (14) (14) (14) (14) (14) (14) (14) (14) (14) (14) (15) (15) (15) (2) (2) (2) (3) (3) (3) (3) (3) (3) (3) (3) (3) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (5) (5) (5) (5) (5) (5) (6) (6) (6) (6) (7) (7) (7) (7) (7) (7) (7) (7))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (scale inport outport deltapict cmnpref staff fontsize approx zoom notechancolor? grillestep mode winsize winpos palette-mode obj-mode show-stems)) (list nil 0 0 (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote ggff) 24 2 67/100 nil 1000 4 (om-make-point 1230 460) (om-make-point 10 40) 0 0 nil)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 212 32) (quote "CF and melodic sequence.") "" (om-make-point 557 38) nil (om-make-color 0 0 0) (om-make-font "Geneva" 10 :family "Geneva" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD" (quote chord) (quote ((om-load-inputfun (quote input-funbox) "objs" "SELF" nil) (om-load-inputfun (quote input-funbox) "no documentation" "LMIDIC" (list 6000)) (om-load-inputfun (quote input-funbox) "no documentation" "LVEL" (list 100)) (om-load-inputfun (quote input-funbox) "no documentation" "LOFFSET" (list 0)) (om-load-inputfun (quote input-funbox) "no documentation" "LDUR" (list 1000)) (om-load-inputfun (quote input-funbox) "no documentation" "LCHAN" (list 1)))) (om-make-point 403 125) (om-make-point 55 90) (let ((thechord (make-instance (quote chord) :lmidic (quote (6500 6400 7200 7100 6900 6800 7200 6800 7500 6400 6700 6800)) :ldur (quote (1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000)) :lvel (quote (100 100 100 100 100 100 100 100 100 100 100 100)) :loffset (quote (0 0 0 0 0 0 0 0 0 0 0 0)) :lchan (quote (1 1 1 1 1 1 1 1 1 1 1 1))))) (load-port-info thechord (quote (0 0 0 0 0 0 0 0 0 0 0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) nil nil (pairlis (quote (scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom inport outport deltapict cmnpref staff fontsize approx palette-mode)) (list nil (quote t) 1 0 (om-make-point 443 0) (om-make-point 775 311) 3 1000 nil 1 0 0 (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2 0)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD" (quote chord) (quote ((om-load-inputfun (quote input-funbox) "objs" "SELF" nil) (om-load-inputfun (quote input-funbox) "no documentation" "LMIDIC" (list 6000)) (om-load-inputfun (quote input-funbox) "no documentation" "LVEL" (list 100)) (om-load-inputfun (quote input-funbox) "no documentation" "LOFFSET" (list 0)) (om-load-inputfun (quote input-funbox) "no documentation" "LDUR" (list 1000)) (om-load-inputfun (quote input-funbox) "no documentation" "LCHAN" (list 1)))) (om-make-point 521 141) (om-make-point 55 90) (let ((thechord (make-instance (quote chord) :lmidic (quote (6500 6400 7200 7300)) :ldur (quote (1000 1000 1000 1000)) :lvel (quote (100 100 100 100)) :loffset (quote (0 0 0 0)) :lchan (quote (1 1 1 1))))) (load-port-info thechord (quote (0 0 0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) nil nil (pairlis (quote (scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom inport outport deltapict cmnpref staff fontsize approx palette-mode)) (list nil (quote t) 1 0 (om-make-point 162 336) (om-make-point 846 320) 3 1000 nil 1 0 0 (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2 0)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 100))) (om-make-point 405 85) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 100))) (om-make-point 538 103) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment1" (om-make-point 156 64) (quote "AntÛnio de Sousa Dias$www.sousadias.com$rev. 2008") "" (om-make-point 23 628) nil (om-make-color 0.018735297 0.025613498 0.51131225) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 372 121) (quote "Given a melodic sequence as a Cantus Firmus (CF) and a melodic sequence as an ornamentation reservoir (MS). For each two notes of the CF, this patch finds all excerpts belonging to MS whose extreme notes form the same interval.$The resulting data is prepared to be read by a score editor.") "" (om-make-point 10 42) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 356 35) (quote "2b-Or evaluate here, and open the MIDI File with a score editor.") "" (om-make-point 684 555) nil (om-make-color 0 0 0) (om-make-font "Geneva" 10 :family "Geneva" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 279 220) (quote "The inputs are:$$1- CF (list of MIDIcents)$2- Melodic sequence  (list of MIDIcents)$$3- Length of CF notes, for score viewing purposes (ms)$$4- Length of each generated note (ms)$$5- Number of lines (channels)$$The outputs connect to a chord-seq object.$") "" (om-make-point 847 4) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux5" (quote t) (quote nil) (om-make-point 795 158) (om-make-point 50 29) 14 "14" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux4" (quote t) (quote nil) (om-make-point 586 11) (om-make-point 207 36) (list 65 64 72 71 69 68 72 68 75 64 67 68) "(65 64 72 71 69 68 72 68 75 64 67 68)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD-SEQ11" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "objs" "SELF" nil) (om-load-inputfun (quote input-funbox) "LMIDIC" "LMIDIC" (list 6000)) (om-load-inputfun (quote input-funbox) "LONSET" "LONSET" (list 0 1000)) (om-load-inputfun (quote input-funbox) "LDUR" "LDUR" (list 1000)) (om-load-inputfun (quote input-funbox) "LVEL" "LVEL" (list 100)) (om-load-inputfun (quote input-funbox) "LOFFSET" "LOFFSET" (list 0)) (om-load-inputfun (quote input-funbox) "LCHAN" "LCHAN" (list 1)) (om-load-inputfun (quote input-funbox) "LEGATO" "LEGATO" 0))) (om-make-point 72 358) (om-make-point 470 189) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6500) (6400) (7200) (7100) (6900) (6800) (7200) (6800) (7500) (6400) (6700) (6800) (6500) (6400) (6500) (6400) (7200) (7300) (6500) (7300) (6500) (6600) (5800) (6500) (5700) (5600) (6400) (6400) (6300) (6400) (6300) (7100) (7200) (6400) (7200) (6400) (6500) (5700) (6400) (5600) (5500) (6300) (7200) (7100) (7200) (7100) (7900) (8000) (7200) (8000) (7200) (7300) (6500) (7200) (6400) (6300) (7100) (7100) (7000) (7800) (7100) (7900) (8000) (7200) (7100) (7200) (7100) (7200) (6400) (6300) (7100) (6300) (6900) (6800) (6900) (6800) (7600) (7700) (6900) (7700) (6900) (7000) (6200) (6900) (6100) (6000) (6800) (6800) (6700) (7500) (6800) (7600) (7700) (6900) (6800) (6900) (6800) (6900) (6100) (6000) (6800) (6000) (7200) (7100) (7200) (7100) (7900) (8000) (7200) (8000) (7200) (7300) (6500) (7200) (6400) (6300) (7100) (6800) (6700) (7500) (6800) (7600) (7700) (6900) (6800) (6900) (6800) (6900) (6100) (6000) (6800) (6000) (7500) (7400) (8200) (7500) (8300) (8400) (7600) (7500) (7600) (7500) (7600) (6800) (6700) (7500) (6700) (6400) (6300) (7100) (7200) (6400) (6400) (7200) (7300) (6400) (7200) (7300) (6500) (6400) (6400) (6500) (5700) (5600) (6400) (6400) (5600) (5500) (6400) (5600) (5500) (6300) (6400) (6700) (6600) (7400) (6700) (7500) (7600) (6800) (6700) (6800) (6700) (6800) (6000) (5900) (6700) (5900) (6800) (6700) (7500) (7600) (6800) (6800) (7600) (7700) (6800) (7600) (7700) (6900) (6800) (6800) (6900) (6100) (6000) (6800) (6800) (6000) (5900) (6800) (6000) (5900) (6700) (6800))) :lonset (quote (0 8000 16000 24000 32000 40000 48000 56000 64000 72000 80000 88000 0 125 0 125 250 375 0 125 0 125 250 0 125 250 375 8000 8125 8000 8125 8250 8375 8000 8125 8000 8125 8250 8000 8125 8250 8375 16000 16125 16000 16125 16250 16375 16000 16125 16000 16125 16250 16000 16125 16250 16375 24000 24125 24250 24000 24125 24250 24375 24000 24125 24000 24125 24250 24375 24000 24125 32000 32125 32000 32125 32250 32375 32000 32125 32000 32125 32250 32000 32125 32250 32375 40000 40125 40250 40000 40125 40250 40375 40000 40125 40000 40125 40250 40375 40000 40125 48000 48125 48000 48125 48250 48375 48000 48125 48000 48125 48250 48000 48125 48250 48375 56000 56125 56250 56000 56125 56250 56375 56000 56125 56000 56125 56250 56375 56000 56125 64000 64125 64250 64000 64125 64250 64375 64000 64125 64000 64125 64250 64375 64000 64125 72000 72125 72250 72375 72500 72000 72125 72250 72000 72125 72250 72375 72500 72000 72125 72250 72375 72500 72000 72125 72250 72000 72125 72250 72375 72500 80000 80125 80250 80000 80125 80250 80375 80000 80125 80000 80125 80250 80375 80000 80125 88000 88125 88250 88375 88500 88000 88125 88250 88000 88125 88250 88375 88500 88000 88125 88250 88375 88500 88000 88125 88250 88000 88125 88250 88375 88500 96000)) :ldur (quote ((8000) (8000) (8000) (8000) (8000) (8000) (8000) (8000) (8000) (8000) (8000) (8000) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125) (125))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (2) (3) (3) (3) (3) (4) (4) (5) (5) (5) (6) (6) (6) (6) (2) (2) (3) (3) (3) (3) (4) (4) (5) (5) (5) (6) (6) (6) (6) (2) (2) (3) (3) (3) (3) (4) (4) (5) (5) (5) (6) (6) (6) (6) (2) (2) (2) (3) (3) (3) (3) (4) (4) (5) (5) (5) (5) (6) (6) (2) (2) (3) (3) (3) (3) (4) (4) (5) (5) (5) (6) (6) (6) (6) (2) (2) (2) (3) (3) (3) (3) (4) (4) (5) (5) (5) (5) (6) (6) (2) (2) (3) (3) (3) (3) (4) (4) (5) (5) (5) (6) (6) (6) (6) (2) (2) (2) (3) (3) (3) (3) (4) (4) (5) (5) (5) (5) (6) (6) (2) (2) (2) (3) (3) (3) (3) (4) (4) (5) (5) (5) (5) (6) (6) (2) (2) (2) (2) (2) (3) (3) (3) (4) (4) (4) (4) (4) (5) (5) (5) (5) (5) (6) (6) (6) (7) (7) (7) (7) (7) (2) (2) (2) (3) (3) (3) (3) (4) (4) (5) (5) (5) (5) (6) (6) (2) (2) (2) (2) (2) (3) (3) (3) (4) (4) (4) (4) (4) (5) (5) (5) (5) (5) (6) (6) (6) (7) (7) (7) (7) (7))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (scale inport outport deltapict cmnpref staff fontsize approx zoom notechancolor? grillestep mode winsize winpos palette-mode obj-mode show-stems)) (list nil 0 0 (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote ggff) 24 2 179/100 nil 1000 0 (om-make-point 1230 460) (om-make-point 10 40) 0 0 nil)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 287 42) (quote "2a-Evaluate here, open and save as a MIDI file and open it with a score editor.") "" (om-make-point 175 556) nil (om-make-color 0 0 0) (om-make-font "Geneva" 10 :family "Geneva" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "SAVE-AS-MIDI" (quote save-as-midi) (quote ((om-load-inputfun (quote input-funbox) "a music object to save" "OBJECT" nil))) (om-make-point 86 548) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux211" (quote t) (quote nil) (om-make-point 791 88) (om-make-point 50 28) 4000 "4000" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux2" (quote t) (quote nil) (om-make-point 762 131) (om-make-point 40 28) 125 "125" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux11" (quote t) (quote nil) (om-make-point 572 69) (om-make-point 93 33) (list 65 64 72 73) "(65 64 72 73)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((7 1 0 0 nil 12) (8 1 0 1 nil 4) (20 0 0 2 nil 1) (21 0 0 3 nil 2) (15 0 0 4 nil 3) (22 0 1 0 nil 4) (16 0 1 1 nil 12) (20 0 1 2 nil 1) (21 0 1 3 nil 2) (15 0 1 4 nil 3) (5 0 4 0 nil 0) (1 1 5 1 nil 0) (1 2 5 2 nil 0) (1 3 5 3 nil 0) (1 4 5 6 nil 0) (9 0 7 1 nil 0) (10 0 8 1 nil 0) (16 0 9 0 nil 12) (22 0 10 0 nil 4) (0 1 17 1 nil 0) (0 2 17 2 nil 0) (0 3 17 3 nil 0) (0 4 17 6 nil 0) (17 0 19 0 nil 0))) nil 6.130002))
